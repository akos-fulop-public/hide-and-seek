<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<title>Vienna Game Map</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />

	<link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />

	<style>
		html,
		body {
			margin: 0;
			padding: 0;
			height: 100%;
		}

		#map {
			width: 100%;
			height: 100%;
		}

		#menu-container {
			position: absolute;
			bottom: 10px;
			right: 10px;
			background: white;
			border-radius: 4px;
			box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
			width: max-content;
			font-family: sans-serif;
		}

		#menu-toggle {
			display: block;
			background: none;
			border: none;
			padding: 6px 12px;
			cursor: pointer;
			font-weight: bold;
		}

		#menu-content {
			display: none;
			/* initially hidden */
			flex-direction: column;
			gap: 4px;
			padding: 4px 12px;
		}

		#menu-content label {
			white-space: nowrap;
		}
	</style>
</head>

<body>

	<div id="map"></div>
	<div id="menu-container">
		<button id="menu-toggle">Layers ▼</button>
		<div id="menu-content">
			<label><input type="checkbox" id="toggle-transport" checked>Show Transport</label>
			<label><input type="checkbox" id="toggle-zones" checked>Show Hiding Zones</label>
		</div>
	</div>

	<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

	<script>
		function extendBounds(bounds, geometry) {
			if (geometry.type === 'Polygon') {
				geometry.coordinates.forEach(ring => ring.forEach(coord => bounds.extend(coord)));
			} else if (geometry.type === 'MultiPolygon') {
				geometry.coordinates.forEach(polygon => {
					polygon.forEach(ring => ring.forEach(coord => bounds.extend(coord)));
				});
			}
		}

		function padBounds(bounds, factor = 0.05) {
			const sw = bounds.getSouthWest();
			const ne = bounds.getNorthEast();

			const latPad = (ne.lat - sw.lat) * factor;
			const lngPad = (ne.lng - sw.lng) * factor;

			return new maplibregl.LngLatBounds(
				[sw.lng - lngPad, sw.lat - latPad],
				[ne.lng + lngPad, ne.lat + latPad]
			);
		}

		fetch('data/districts.geojson')
			.then(res => res.json())
			.then(geojson => {
				const bounds = new maplibregl.LngLatBounds();
				geojson.features.forEach(feature => extendBounds(bounds, feature.geometry));

				// Apply padding to maxBounds
				const paddedBounds = padBounds(bounds, 0.2);

				const map = new maplibregl.Map({
					container: 'map',
					style: 'style.json',
					maxBounds: paddedBounds,
					minZoom: 10,
					maxZoom: 16
				});

				map.addControl(new maplibregl.NavigationControl());

				map.on('load', () => {
					// fitBounds uses the original bounds with its own padding
					map.fitBounds(bounds, { padding: 40 });

					const transportLayers = ["lines", "stations"];

					document.getElementById("toggle-transport").addEventListener("change", function (e) {
						const visible = e.target.checked ? "visible" : "none";

						transportLayers.forEach(layerId => {
							if (map.getLayer(layerId)) {
								map.setLayoutProperty(layerId, "visibility", visible);
							}
						});
					});
					document.getElementById("toggle-zones").addEventListener("change", function (e) {
						const visible = e.target.checked ? "visible" : "none";
						if (map.getLayer("hiding-zones")) {
							map.setLayoutProperty("hiding-zones", "visibility", visible);
						}
					});

					const toggleButton = document.getElementById("menu-toggle");
					const menuContent = document.getElementById("menu-content");

					toggleButton.addEventListener("click", () => {
						if (menuContent.style.display === "flex") {
							menuContent.style.display = "none";
							toggleButton.textContent = "Layers ▼";
						} else {
							menuContent.style.display = "flex";
							toggleButton.textContent = "Layers ▲";
						}
					});
				});
			});

	</script>

</body>

</html>
